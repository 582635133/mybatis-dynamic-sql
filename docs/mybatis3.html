<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/docs/mybatis3.md at 23 November 2019
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20191123" />
    <meta http-equiv="Content-Language" content="en" />
    <title>MyBatis Dynamic SQL &#x2013; Specialized Support for MyBatis3</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script type="text/javascript" src="../js/apache-maven-fluido-1.7.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h2>MyBatis Dynamic SQL</h2>
</a></div>
        <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 23 November 2019<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.1.4</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
    <ul class="nav nav-list">
    <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
    </ul>
</li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
    <ul class="nav nav-list">
    <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
    </ul>
</li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li class="active"><a href="#"><span class="none"></span>MyBatis3 Support</a></li>
    <li><a href="../docs/kotlinMyBatis3.html" title="Kotlin Support for MyBatis3"><span class="none"></span>Kotlin Support for MyBatis3</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li><a href="../docs/kotlinSpring.html" title="Kotlin Support for Spring"><span class="none"></span>Kotlin Support for Spring</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Specialized Support for MyBatis3</h1>
<p>Most of the examples shown on this site are for usage with MyBatis3 - even though the library does support other SQL runtimes like Spring JDBC templates. In addition to the examples shown elsewhere, the library has additional specialized support for MyBatis3 beyond what is shown in the other examples. This support mainly exists to support MyBatis Generator and the code generated by that tool. Even without MyBatis Generator, some of the techniques shown on this page may prove useful.</p>
<p>The goal of this support is to reduce the amount of boilerplate code needed for a typical CRUD mapper. For example, this support allows you to create a reusable SELECT method where the user only needs to specify a WHERE clause.</p>
<p>With version 1.1.3, specialized interfaces and utilities were added that can further simplify client code. This support enables the creation of methods that have similar functionality to some of the methods generated in previous versions of MyBatis generator like countByExample, deleteByExample, and selectByExample. We no longer use the &#x201c;by example&#x201d; terms for these methods as this library has eliminated the Example class that was generated by prior versions of MyBatis Generator.</p>
<div class="section">
<h2><a name="Count_Method_Support"></a>Count Method Support</h2>
<p>The goal of count method support is to enable the creation of methods that execute a count query allowing a user to specify a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating two methods on a MyBatis mapper interface. The first method is the standard MyBatis Dynamic SQL method that will execute a select:</p>

<div>
<div>
<pre class="source">@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
long count(SelectStatementProvider selectStatement);
</pre></div></div>

<p>This is a standard method for MyBatis Dynamic SQL that executes a query and returns a <tt>long</tt>. The second method will reuse this method and supply everything needed to build the select statement except the where clause:</p>

<div>
<div>
<pre class="source">default long count(CountDSLCompleter completer) {
    return MyBatis3Utils.countFrom(this::count, person, completer);
}
</pre></div></div>

<p>This method shows the use of <tt>CountDSLCompleter</tt> which is a specialization of a <tt>java.util.Function</tt> that will allow a user to supply a where clause. Clients can use the method as follows:</p>

<div>
<div>
<pre class="source">long rows = mapper.count(c -&gt;
        c.where(occupation, isNull()));
</pre></div></div>

<p>There is a utility method that can be used to count all rows in a table:</p>

<div>
<div>
<pre class="source">long rows = mapper.count(CountDSLCompleter.allRows());
</pre></div></div>
</div>
<div class="section">
<h2><a name="Delete_Method_Support"></a>Delete Method Support</h2>
<p>The goal of delete method support is to enable the creation of methods that execute a delete statement allowing a user to specify a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating two methods on a MyBatis mapper interface. The first method is the standard MyBatis Dynamic SQL method that will execute a delete:</p>

<div>
<div>
<pre class="source">@DeleteProvider(type=SqlProviderAdapter.class, method=&quot;delete&quot;)
int delete(DeleteStatementProvider deleteStatement);
</pre></div></div>

<p>This is a standard method for MyBatis Dynamic SQL that executes a delete and returns an <tt>int</tt> - the number of rows deleted. The second method will reuse this method and supply everything needed to build the delete statement except the where clause:</p>

<div>
<div>
<pre class="source">default int delete(DeleteDSLCompleter completer) {
    return MyBatis3Utils.deleteFrom(this::delete, person, completer);
}
</pre></div></div>

<p>This method shows the use of <tt>DeleteDSLCompleter</tt> which is a specialization of a <tt>java.util.Function</tt> that will allow a user to supply a where clause. Clients can use the method as follows:</p>

<div>
<div>
<pre class="source">int rows = mapper.delete(c -&gt;
        c.where(occupation, isNull()));
</pre></div></div>

<p>There is a utility method that can be used to delete all rows in a table:</p>

<div>
<div>
<pre class="source">int rows = mapper.delete(DeleteDSLCompleter.allRows());
</pre></div></div>
</div>
<div class="section">
<h2><a name="Insert_Method_Support"></a>Insert Method Support</h2>
<p>The goal of insert method support is to remove some of the boilerplate code from insert methods in a mapper interfaces.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first two methods are the standard MyBatis Dynamic SQL method that will execute an insert:</p>

<div>
<div>
<pre class="source">@InsertProvider(type=SqlProviderAdapter.class, method=&quot;insert&quot;)
int insert(InsertStatementProvider&lt;PersonRecord&gt; insertStatement);

@InsertProvider(type=SqlProviderAdapter.class, method=&quot;insertMultiple&quot;)
int insertMultiple(MultiRowInsertStatementProvider&lt;PersonRecord&gt; insertStatement);
</pre></div></div>

<p>These two methods are standard methods for MyBatis Dynamic SQL. They execute a single row insert and a multiple row insert.</p>
<p>These methods can be used to implement simplified insert methods:</p>

<div>
<div>
<pre class="source">default int insert(PersonRecord record) {
    return MyBatis3Utils.insert(this::insert, record, person, c -&gt; 
        c.map(id).toProperty(&quot;id&quot;)
        .map(firstName).toProperty(&quot;firstName&quot;)
        .map(lastName).toProperty(&quot;lastName&quot;)
        .map(birthDate).toProperty(&quot;birthDate&quot;)
        .map(employed).toProperty(&quot;employed&quot;)
        .map(occupation).toProperty(&quot;occupation&quot;)
        .map(addressId).toProperty(&quot;addressId&quot;)
    );
}

default int insertMultiple(PersonRecord...records) {
    return insertMultiple(Arrays.asList(records));
}

default int insertMultiple(Collection&lt;PersonRecord&gt; records) {
    return MyBatis3Utils.insertMultiple(this::insertMultiple, records, person, c -&gt;
        c.map(id).toProperty(&quot;id&quot;)
        .map(firstName).toProperty(&quot;firstName&quot;)
        .map(lastName).toProperty(&quot;lastName&quot;)
        .map(birthDate).toProperty(&quot;birthDate&quot;)
        .map(employed).toProperty(&quot;employed&quot;)
        .map(occupation).toProperty(&quot;occupation&quot;)
        .map(addressId).toProperty(&quot;addressId&quot;)
    );
}
</pre></div></div>

<p>In the mapper, only the column mappings need to be specified and no other boilerplate code is needed.</p></div>
<div class="section">
<h2><a name="Select_Method_Support"></a>Select Method Support</h2>
<p>The goal of select method support is to enable the creation of methods that execute a select statement allowing a user to specify a where clause and/or order by clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first two methods are the standard MyBatis Dynamic SQL method that will execute a select:</p>

<div>
<div>
<pre class="source">@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
@Results(id=&quot;PersonResult&quot;, value= {
        @Result(column=&quot;A_ID&quot;, property=&quot;id&quot;, jdbcType=JdbcType.INTEGER, id=true),
        @Result(column=&quot;first_name&quot;, property=&quot;firstName&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;last_name&quot;, property=&quot;lastName&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;birth_date&quot;, property=&quot;birthDate&quot;, jdbcType=JdbcType.DATE),
        @Result(column=&quot;employed&quot;, property=&quot;employed&quot;, jdbcType=JdbcType.VARCHAR),
        @Result(column=&quot;occupation&quot;, property=&quot;occupation&quot;, jdbcType=JdbcType.VARCHAR)
})
List&lt;PersonRecord&gt; selectMany(SelectStatementProvider selectStatement);
    
@SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
@ResultMap(&quot;PersonResult&quot;)
Optional&lt;PersonRecord&gt; selectOne(SelectStatementProvider selectStatement);
</pre></div></div>

<p>These two methods are standard methods for MyBatis Dynamic SQL. They execute a select and return either a list of records, or a single record.</p>
<p>We also envision creating a static field for a reusable list of columns for a select statement:</p>

<div>
<div>
<pre class="source">BasicColumn[] selectList =
    BasicColumn.columnList(id.as(&quot;A_ID&quot;), firstName, lastName, birthDate, employed, occupation, addressId);
</pre></div></div>

<p>The <tt>selectOne</tt> method can be used to implement a generalized select one method:</p>

<div>
<div>
<pre class="source">default Optional&lt;PersonRecord&gt; selectOne(SelectDSLCompleter completer) {
    return MyBatis3Utils.selectOne(this::selectOne, selectList, person, completer);
}
</pre></div></div>

<p>This method shows the use of <tt>SelectDSLCompleter</tt> which is a specialization of a <tt>java.util.Function</tt> that will allow a user to supply a where clause.</p>
<p>The general <tt>selectOne</tt> method can be used to implement a <tt>selectByPrimaryKey</tt> method:</p>

<div>
<div>
<pre class="source">default Optional&lt;PersonRecord&gt; selectByPrimaryKey(Integer id_) {
    return selectOne(c -&gt;
        c.where(id, isEqualTo(id_))
    );
}
</pre></div></div>

<p>The <tt>selectMany</tt> method can be used to implement generalized select methods where a user can specify a where clause and/or an order by clause. Typically we recommend two of these methods - for select, and select distinct:</p>

<div>
<div>
<pre class="source">default List&lt;PersonRecord&gt; select(SelectDSLCompleter completer) {
    return MyBatis3Utils.selectList(this::selectMany, selectList, person, completer);
}
    
default List&lt;PersonRecord&gt; selectDistinct(SelectDSLCompleter completer) {
    return MyBatis3Utils.selectDistinct(this::selectMany, selectList, person, completer);
}
</pre></div></div>

<p>These methods show the use of <tt>MyBatis3SelectListHelper</tt> which is a specialization of a <tt>java.util.Function</tt> that will allow a user to supply a where clause and/or an order by clause.</p>
<p>Clients can use the methods as follows:</p>

<div>
<div>
<pre class="source">List&lt;PersonRecord&gt; rows = mapper.select(c -&gt;
        c.where(id, isEqualTo(1))
        .or(occupation, isNull()));
</pre></div></div>

<p>There are utility methods that will select all rows in a table:</p>

<div>
<div>
<pre class="source">List&lt;PersonRecord&gt; rows =
    mapper.selectByExample(SelectDSLCompleter.allRows());
</pre></div></div>

<p>The following query will select all rows in a specified order:</p>

<div>
<div>
<pre class="source">List&lt;PersonRecord&gt; rows =
    mapper.selectByExample(SelectDSLCompleter.allRowsOrderedBy(lastName, firstName));
</pre></div></div>
</div>
<div class="section">
<h2><a name="Update_Method_Support"></a>Update Method Support</h2>
<p>The goal of update method support is to enable the creation of methods that execute an update statement allowing a user to specify values to set and a where clause at runtime, but abstracting away all other details.</p>
<p>To use this support, we envision creating several methods on a MyBatis mapper interface. The first method is a standard MyBatis Dynamic SQL method that will execute a update:</p>

<div>
<div>
<pre class="source">@UpdateProvider(type=SqlProviderAdapter.class, method=&quot;update&quot;)
int update(UpdateStatementProvider updateStatement);
</pre></div></div>

<p>This is a standard method for MyBatis Dynamic SQL that executes a query and returns an <tt>int</tt> - the number of rows updated. The second method will reuse this method and supply everything needed to build the update statement except the values and the where clause:</p>

<div>
<div>
<pre class="source">default int update(UpdateDSLCompleter completer) {
    return MyBatis3Utils.update(this::update, person, completer);
}
</pre></div></div>

<p>This method shows the use of <tt>UpdateDSLCompleter</tt> which is a specialization of a <tt>java.util.Function</tt> that will allow a user to supply values and a where clause. Clients can use the method as follows:</p>

<div>
<div>
<pre class="source">int rows = mapper.update(c -&gt;
    c.set(occupation).equalTo(&quot;Programmer&quot;)
    .where(id, isEqualTo(100)));
</pre></div></div>

<p>All rows in a table can be updated by simply omitting the where clause:</p>

<div>
<div>
<pre class="source">int rows = mapper.update(c -&gt;
    c.set(occupation).equalTo(&quot;Programmer&quot;));
</pre></div></div>

<p>It is also possible to write a utility method that will set values. For example:</p>

<div>
<div>
<pre class="source">static UpdateDSL&lt;UpdateModel&gt; updateSelectiveColumns(PersonRecord record,
        UpdateDSL&lt;UpdateModel&gt; dsl) {
    return dsl.set(id).equalToWhenPresent(record::getId)
            .set(firstName).equalToWhenPresent(record::getFirstName)
            .set(lastName).equalToWhenPresent(record::getLastName)
            .set(birthDate).equalToWhenPresent(record::getBirthDate)
            .set(employed).equalToWhenPresent(record::getEmployed)
            .set(occupation).equalToWhenPresent(record::getOccupation);
}
</pre></div></div>

<p>This method will selectively set values if corresponding fields in a record are non null. This method can be used as follows:</p>

<div>
<div>
<pre class="source">rows = mapper.update(h -&gt;
    updateSelectiveColumns(updateRecord, h)
    .where(id, isEqualTo(100)));
</pre></div></div>

<h1>Prior Support</h1>
<p>Prior to version 1.1.3, it was also possible to write reusable methods, but they were a bit inconsistent with other helper methods.  Mappers of this style are deprecated and the support classes for mappers of this style will be removed in a future version of this library.</p>
<p>For example, it is possible to write a mapper interface like this:</p>

<div>
<div>
<pre class="source">import static examples.simple.PersonDynamicSqlSupport.*;

import java.util.List;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Result;
import org.apache.ibatis.annotations.Results;
import org.apache.ibatis.annotations.SelectProvider;
import org.apache.ibatis.type.JdbcType;
import org.mybatis.dynamic.sql.select.MyBatis3SelectModelAdapter;
import org.mybatis.dynamic.sql.select.QueryExpressionDSL;
import org.mybatis.dynamic.sql.select.SelectDSL;
import org.mybatis.dynamic.sql.select.render.SelectStatementProvider;
import org.mybatis.dynamic.sql.util.SqlProviderAdapter;

@Mapper
public interface LegacyPersonMapper {
    
    @SelectProvider(type=SqlProviderAdapter.class, method=&quot;select&quot;)
    @Results(id=&quot;PersonResult&quot;, value= {
            @Result(column=&quot;A_ID&quot;, property=&quot;id&quot;, jdbcType=JdbcType.INTEGER, id=true),
            @Result(column=&quot;first_name&quot;, property=&quot;firstName&quot;, jdbcType=JdbcType.VARCHAR),
            @Result(column=&quot;last_name&quot;, property=&quot;lastName&quot;, jdbcType=JdbcType.VARCHAR),
            @Result(column=&quot;birth_date&quot;, property=&quot;birthDate&quot;, jdbcType=JdbcType.DATE),
            @Result(column=&quot;employed&quot;, property=&quot;employed&quot;, jdbcType=JdbcType.VARCHAR, typeHandler=YesNoTypeHandler.class),
            @Result(column=&quot;occupation&quot;, property=&quot;occupation&quot;, jdbcType=JdbcType.VARCHAR)
    })
    List&lt;PersonRecord&gt; selectMany(SelectStatementProvider selectStatement);
    
    default QueryExpressionDSL&lt;MyBatis3SelectModelAdapter&lt;List&lt;PersonRecord&gt;&gt;&gt; selectByExample() {
        return SelectDSL.selectWithMapper(this::selectMany, id.as(&quot;A_ID&quot;), firstName, lastName, birthDate, employed, occupation)
            .from(simpleTable);
    }
}
</pre></div></div>

<p>Notice the <tt>selectByExample</tt> method - it specifies the column list and table name and returns the intermediate builder that can be used to finish the WHERE clause.  It also reuses the <tt>selectMany</tt> mapper method.  Mapper methods built using this added support all finish with an <tt>execute</tt> method that builds the statement and executes the mapper method.</p>
<p>The code is used like this:</p>

<div>
<div>
<pre class="source">    List&lt;PersonRecord&gt; rows = mapper.selectByExample()
            .where(id, isEqualTo(1))
            .or(occupation, isNull())
            .build()
            .execute();
</pre></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2016&#x2013;2019
<a href="http://www.mybatis.org/">MyBatis.org</a>.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>

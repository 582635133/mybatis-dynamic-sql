<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/docs/kotlinSpring.md at 16 September 2019
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20190916" />
    <meta http-equiv="Content-Language" content="en" />
    <title>MyBatis Dynamic SQL &#x2013; Kotlin Support for Spring</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script type="text/javascript" src="../js/apache-maven-fluido-1.7.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h2>MyBatis Dynamic SQL</h2>
</a></div>
        <div class="pull-right"><a href="../../" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 16 September 2019<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.1.3</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
    <ul class="nav nav-list">
    <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
    </ul>
</li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
    <ul class="nav nav-list">
    <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
    </ul>
</li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/mybatis3.html" title="MyBatis3 Support"><span class="none"></span>MyBatis3 Support</a></li>
    <li><a href="../docs/kotlinMyBatis3.html" title="Kotlin Support for MyBatis3"><span class="none"></span>Kotlin Support for MyBatis3</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li class="active"><a href="#"><span class="none"></span>Kotlin Support for Spring</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Kotlin Support for Spring</h1>
<p>MyBatis Dynamic SQL includes Kotlin extension methods that enable an SQL DSL for Kotlin. This is the recommended method of using the library in Kotlin with Spring JDBC template.</p>
<p>This page will show our recommended pattern for using the MyBatis Dynamic SQL with Kotlin and Spring JDBC Template. The code shown on this page is from the <tt>src/test/kotlin/examples/kotlin/spring/canonical</tt> directory in this repository. That directory contains a complete example of using this library with Kotlin and Spring.</p>
<p>All Kotlin support for Spring is available in two packages:</p>
<ul>

<li><tt>org.mybatis.dynamic.sql.util.kotlin</tt> - contains extension methods and utilities to enable an idiomatic Kotlin DSL for MyBatis Dynamic SQL. These objects can be used for clients using any execution target (i.e. MyBatis3 or Spring JDBC Templates)</li>
<li><tt>org.mybatis.dynamic.sql.util.kotlin.spring</tt> - contains utlities specifically to simplify integration with Spring JDBC Template</li>
</ul>
<p>The Kotlin support for Spring is implemented as extension methods to <tt>NamedParameterJdbcTemplate</tt>. There are extension methods to support count, delete, insert, select, and update operations based on SQL generated by this library. For each operation, there are two different methods of executing SQL. With the first method you build the appropriate SQL provider object as a separate step before executing the SQL. The second method combines these two operations into a single step. We will illustrate both approaches below.</p>
<div class="section">
<h2><a name="Kotlin_Dynamic_SQL_Support_Objects"></a>Kotlin Dynamic SQL Support Objects</h2>
<p>Because Kotlin does not support static class members, we recommend a simpler pattern for creating the class containing the support objects. For example:</p>

<div>
<div>
<pre class="source">object PersonDynamicSqlSupport {
    object Person : SqlTable(&quot;Person&quot;) {
        val id = column&lt;Int&gt;(&quot;id&quot;, JDBCType.INTEGER)
        val firstName = column&lt;String&gt;(&quot;first_name&quot;, JDBCType.VARCHAR)
        val lastName = column&lt;String&gt;(&quot;last_name&quot;, JDBCType.VARCHAR)
        val birthDate = column&lt;Date&gt;(&quot;birth_date&quot;, JDBCType.DATE)
        val employed = column&lt;String&gt;(&quot;employed&quot;, JDBCType.VARCHAR)
        val occupation = column&lt;String&gt;(&quot;occupation&quot;, JDBCType.VARCHAR)
        val addressId = column&lt;Int&gt;(&quot;address_id&quot;, JDBCType.INTEGER)
    }
}
</pre></div></div>

<p>This object is a singleton containing the <tt>SqlTable</tt> and <tt>SqlColumn</tt> objects that map to the database table.</p>
<p><b>Important Note:</b> Spring JDBC template does not support type handlers, so column definitions in the support class should match the data types of the corresponding column.</p></div>
<div class="section">
<h2><a name="Count_Method_Support"></a>Count Method Support</h2>
<p>A count query is a specialized select - it returns a single column - typically a long - and supports joins and a where clause.</p>
<p>The DSL for count methods looks like this:</p>

<div>
<div>
<pre class="source">    val countStatement = countFrom(Person) {  // countStatement is a SelectStatementProvider
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>This code creates a <tt>SelectStatementProvider</tt> that can be executed with an extension method for <tt>NamedParameterJdbcTemplate</tt> like this:</p>

<div>
<div>
<pre class="source">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.count(countStatement) // rows is a Long
</pre></div></div>

<p>This is the two step execution process. This can be combined into a single step with code like the following:</p>

<div>
<div>
<pre class="source">    val rows = template.countFrom(Person) {
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>There is also an extention method that can be used to count all rows in a table:</p>

<div>
<div>
<pre class="source">    val rows = template.countFrom(Person) {
        allRows()
    }
</pre></div></div>
</div>
<div class="section">
<h2><a name="Delete_Method_Support"></a>Delete Method Support</h2>
<p>Delete method support enables the creation of methods that execute a delete statement allowing a user to specify a where clause at runtime, but abstracting away all other details.</p>
<p>The DSL for delete methods looks like this:</p>

<div>
<div>
<pre class="source">    val deleteStatement = deleteFrom(Person) {  // deleteStatement is a DeleteStatementProvider
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>This code creates a <tt>DeleteStatementProvider</tt> that can be executed with an extension method for <tt>NamedParameterJdbcTemplate</tt> like this:</p>

<div>
<div>
<pre class="source">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.delete(deleteStatement)  // rows is an Int
</pre></div></div>

<p>This is the two step execution process. This can be combined into a single step with code like the following:</p>

<div>
<div>
<pre class="source">    val rows = template.deleteFrom(Person) {
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>There is also an extention method that can be used to count all rows in a table:</p>

<div>
<div>
<pre class="source">    val rows = template.deleteFrom(Person) {
        allRows()
    }
</pre></div></div>
</div>
<div class="section">
<h2><a name="Insert_Method_Support"></a>Insert Method Support</h2>
<p>Insert method support enables the creation of arbitrary insert statements.</p>
<p>The DSL for insert methods looks like this:</p>

<div>
<div>
<pre class="source">    val record = PersonRecord(100, &quot;Joe&quot;, &quot;Jones&quot;, Date(), &quot;Yes&quot;, &quot;Developer&quot;, 1)

    val insertStatement = insert(record).into(Person) {  // insertStatement is an InsertStatementProvider
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastName&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employed&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }
</pre></div></div>

<p>This code creates an <tt>InsertStatementProvider</tt> that can be executed with an extension method for <tt>NamedParameterJdbcTemplate</tt> like this:</p>

<div>
<div>
<pre class="source">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.insert(insertStatement)  // rows is an Int
</pre></div></div>

<p>This is the two step execution process. This can be combined into a single step with code like the following:</p>

<div>
<div>
<pre class="source">    val record = PersonRecord(100, &quot;Joe&quot;, &quot;Jones&quot;, Date(), &quot;Yes&quot;, &quot;Developer&quot;, 1)

    val rows = template.insert(record, Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastName&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employed&quot;)
        map(occupation).toPropertyWhenPresent(&quot;occupation&quot;, record::occupation)
        map(addressId).toProperty(&quot;addressId&quot;)
    }
</pre></div></div>

<p>Note the use of the <tt>toPropertyWhenPresent</tt> mapping - this will only set the insert value if the value of the property is non null. Also note that you can use the mapping methods to map insert fields to nulls and constants if desired.</p></div>
<div class="section">
<h2><a name="Select_Method_Support"></a>Select Method Support</h2>
<p>Select method support enables the creation of methods that execute a query allowing a user to specify a where clause and/or an order by clause and/or pagination clauses at runtime, but abstracting away all other details.</p>
<p>The DSL for select methods looks like this:</p>

<div>
<div>
<pre class="source">    val selectStatement = select(id, firstName, lastName, birthDate, employed, occupation,  // selectStatement is a SelectStatementProvider
        addressId).from(Person) {
        where(id, isLessThan(5))
        and(id, isLessThan(4)) {
            and(id, isLessThan(3)) {
                and(id, isLessThan(2))
            }
        }
        orderBy(id)
        limit(3)
    }
</pre></div></div>

<p>This code creates a <tt>SelectStatementProvider</tt> that can be executed with an extension method for <tt>NamedParameterJdbcTemplate</tt> like this:</p>

<div>
<div>
<pre class="source">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.selectList(selectStatement) { rs, _ -&gt; // rows is a List of PersonRecord in this case
        val record = PersonRecord()
        record.id = rs.getInt(1)
        record.firstName = rs.getString(2)
        record.lastName = rs.getString(3)
        record.birthDate = rs.getTimestamp(4)
        record.employed = rs.getString(5)
        record.occupation = rs.getString(6)
        record.addressId = rs.getInt(7)
        record
    }
</pre></div></div>

<p>Note that you must provide a row mapper to tell Spring JDBC how to create result objects.</p>
<p>This is the two step execution process. This can be combined into a single step with code like the following:</p>

<div>
<div>
<pre class="source">    val rows = template.select(id, firstName, lastName, birthDate, employed, occupation, addressId)
        .from(Person) {
            where(id, isLessThan(4)) {
                and(occupation, isNotNull())
            }
            and(occupation, isNotNull())
            orderBy(id)
            limit(3)
        }.withRowMapper { rs, _ -&gt;
            val record = PersonRecord()
            record.id = rs.getInt(1)
            record.firstName = rs.getString(2)
            record.lastName = rs.getString(3)
            record.birthDate = rs.getTimestamp(4)
            record.employed = rs.getString(5)
            record.occupation = rs.getString(6)
            record.addressId = rs.getInt(7)
            record
        }
</pre></div></div>

<p>There are similar methods for selecing a single row, or executing a select distinct query. For example, you could implement a &#x201c;select by primary key&#x201d; method using code like this:</p>

<div>
<div>
<pre class="source">    val record = template.selectOne(id, firstName, lastName, birthDate, employed, occupation, addressId)
        .from(Person) {
            where(id, isEqualTo(key))
        }.withRowMapper { rs, _ -&gt;
            val record = PersonRecord()
            record.id = rs.getInt(1)
            record.firstName = rs.getString(2)
            record.lastName = rs.getString(3)
            record.birthDate = rs.getTimestamp(4)
            record.employed = rs.getString(5)
            record.occupation = rs.getString(6)
            record.addressId = rs.getInt(7)
            record
        }
</pre></div></div>

<p>In this case, the data type for <tt>record</tt> would be <tt>PersonRecord?</tt> - a nullable value.</p>
<p>There is also an extention method that can be used to select all rows in a table:</p>

<div>
<div>
<pre class="source">    val rows = template.select(id, firstName, lastName, birthDate, employed, occupation, addressId)
        .from(Person) {
            allRows()
            orderBy(id)
        }.withRowMapper { rs, _ -&gt;
            val record = PersonRecord()
            record.id = rs.getInt(1)
            record.firstName = rs.getString(2)
            record.lastName = rs.getString(3)
            record.birthDate = rs.getTimestamp(4)
            record.employed = rs.getString(5)
            record.occupation = rs.getString(6)
            record.addressId = rs.getInt(7)
            record
        }
</pre></div></div>

<p>Note that we have supplied an <tt>order by</tt> clause as well.</p></div>
<div class="section">
<h2><a name="Update_Method_Support"></a>Update Method Support</h2>
<p>Update method support enables the creation of methods that execute an update allowing a user to specify SET clauses and/or a WHERE clause, but abstracting away all other details.</p>
<p>The DSL for delete methods looks like this:</p>

<div>
<div>
<pre class="source">    val updateStatement = update(Person) {  // updateStatement is an UpdateStatementProvider
        set(firstName).equalTo(&quot;Sam&quot;)
        where(firstName, isEqualTo(&quot;Fred&quot;))
    }
</pre></div></div>

<p>This code creates an <tt>UpdateStatementProvider</tt> that can be executed with an extension method for <tt>NamedParameterJdbcTemplate</tt> like this:</p>

<div>
<div>
<pre class="source">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.update(updateStatement)  // rows is an Int
</pre></div></div>

<p>This is the two step execution process. This can be combined into a single step with code like the following:</p>

<div>
<div>
<pre class="source">    val rows = template.update(Person) {
        set(firstName).equalTo(&quot;Sam&quot;)
        where(firstName, isEqualTo(&quot;Fred&quot;))
    }
</pre></div></div>

<p>There a many different set mappings the allow setting values to null, constantats, etc. There is also a maping that will only set the column value if the passed value is non null.</p>
<p>If you wish to update all rows in a table, simply omit the where clause:</p>

<div>
<div>
<pre class="source">    val rows = template.update(Person) {
        set(firstName).equalTo(&quot;Sam&quot;)
    }
</pre></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2016&#x2013;2019
<a href="http://www.mybatis.org/">MyBatis.org</a>.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
